class NeuralNetwork{constructor(t,i,s){if(t instanceof NeuralNetwork){let i=t;this.input_nodes=i.input_nodes,this.hidden_nodes=i.hidden_nodes,this.output_nodes=i.output_nodes,this.weights_ih=i.weights_ih.copy(),this.weights_ho=i.weights_ho.copy(),this.bias_h=i.bias_h.copy(),this.bias_o=i.bias_o.copy()}else this.input_nodes=t,this.hidden_nodes=i,this.output_nodes=s,this.weights_ih=new Matrix(this.hidden_nodes,this.input_nodes),this.weights_ho=new Matrix(this.output_nodes,this.hidden_nodes),this.weights_ih.randomize(),this.weights_ho.randomize(),this.bias_h=new Matrix(this.hidden_nodes,1),this.bias_o=new Matrix(this.output_nodes,1),this.bias_h.randomize(),this.bias_o.randomize();this.setLearningRate(),this.setActivationFunction()}predict(t){let i=Matrix.fromArray(t),s=Matrix.multiply(this.weights_ih,i);s.add(this.bias_h),s.map(this.activation_function.func);let a=Matrix.multiply(this.weights_ho,s);return a.add(this.bias_o),a.map(this.activation_function.func),a.toArray()}setLearningRate(t=.1){this.learning_rate=t}setActivationFunction(t=sigmoid){this.activation_function=t}train(t,i){let s=Matrix.fromArray(t),a=Matrix.multiply(this.weights_ih,s);a.add(this.bias_h),a.map(this.activation_function.func);let o=Matrix.multiply(this.weights_ho,a);o.add(this.bias_o),o.map(this.activation_function.func);let e=Matrix.fromArray(i),r=Matrix.subtract(e,o),n=Matrix.map(o,this.activation_function.dfunc);n.multiply(r),n.multiply(this.learning_rate);let h=Matrix.transpose(a),l=Matrix.multiply(n,h);this.weights_ho.add(l),this.bias_o.add(n);let d=Matrix.transpose(this.weights_ho),u=Matrix.multiply(d,r),c=Matrix.map(a,this.activation_function.dfunc);c.multiply(u),c.multiply(this.learning_rate);let _=Matrix.transpose(s),p=Matrix.multiply(c,_);this.weights_ih.add(p),this.bias_h.add(c)}serialize(){return JSON.stringify(this)}static deserialize(t){"string"==typeof t&&(t=JSON.parse(t));let i=new NeuralNetwork(t.input_nodes,t.hidden_nodes,t.output_nodes);return i.weights_ih=Matrix.deserialize(t.weights_ih),i.weights_ho=Matrix.deserialize(t.weights_ho),i.bias_h=Matrix.deserialize(t.bias_h),i.bias_o=Matrix.deserialize(t.bias_o),i.learning_rate=t.learning_rate,i}copy(){return new NeuralNetwork(this)}mutate(t){this.weights_ih.map(t),this.weights_ho.map(t),this.bias_h.map(t),this.bias_o.map(t)}}class ActivationFunction{constructor(t,i){this.func=t,this.dfunc=i}}let sigmoid=new ActivationFunction(t=>1/(1+Math.exp(-t)),t=>t*(1-t)),tanh=new ActivationFunction(t=>Math.tanh(t),t=>1-t*t);class Matrix{constructor(t,i){this.rows=t,this.cols=i,this.data=Array(this.rows).fill().map(()=>Array(this.cols).fill(0))}copy(){let t=new Matrix(this.rows,this.cols);for(let i=0;i<this.rows;i++)for(let s=0;s<this.cols;s++)t.data[i][s]=this.data[i][s];return t}static fromArray(t){return new Matrix(t.length,1).map((i,s)=>t[s])}static subtract(t,i){if(t.rows===i.rows&&t.cols===i.cols)return new Matrix(t.rows,t.cols).map((s,a,o)=>t.data[a][o]-i.data[a][o]);console.log("Columns and Rows of A must match Columns and Rows of B.")}toArray(){let t=[];for(let i=0;i<this.rows;i++)for(let s=0;s<this.cols;s++)t.push(this.data[i][s]);return t}randomize(){return this.map(t=>2*Math.random()-1)}add(t){return t instanceof Matrix?this.rows!==t.rows||this.cols!==t.cols?void console.log("Columns and Rows of A must match Columns and Rows of B."):this.map((i,s,a)=>i+t.data[s][a]):this.map(i=>i+t)}static transpose(t){return new Matrix(t.cols,t.rows).map((i,s,a)=>t.data[a][s])}static multiply(t,i){if(t.cols===i.rows)return new Matrix(t.rows,i.cols).map((s,a,o)=>{let e=0;for(let s=0;s<t.cols;s++)e+=t.data[a][s]*i.data[s][o];return e});console.log("Columns of A must match rows of B.")}multiply(t){return t instanceof Matrix?this.rows!==t.rows||this.cols!==t.cols?void console.log("Columns and Rows of A must match Columns and Rows of B."):this.map((i,s,a)=>i*t.data[s][a]):this.map(i=>i*t)}map(t){for(let i=0;i<this.rows;i++)for(let s=0;s<this.cols;s++){let a=this.data[i][s];this.data[i][s]=t(a,i,s)}return this}static map(t,i){return new Matrix(t.rows,t.cols).map((s,a,o)=>i(t.data[a][o],a,o))}print(){return console.table(this.data),this}serialize(){return JSON.stringify(this)}static deserialize(t){"string"==typeof t&&(t=JSON.parse(t));let i=new Matrix(t.rows,t.cols);return i.data=t.data,i}}"undefined"!=typeof module&&(module.exports=Matrix);
